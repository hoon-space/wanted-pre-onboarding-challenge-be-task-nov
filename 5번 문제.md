# Java 의 HashMap

## 0. 시작

---
내가 주도하는 스터디에서 작년에 `HashMap`을 통해 스터디한 적이 있어 관련한 내용을 적어보려 한다.  
해당 클래스의 개념과 원리 그리고 자바 버전에 따른 변화에 대해 다루었다.  


## 1. 개념

---
HashMap은 key-value가 1:1로 매핑되는 자료구조로 내부는 배열로 되어있다. 이를 해시 테이블이라 한다.  
이때 key는 해시 함수를 적용해 배열의 고유한 index를 생성한다.  
index를 이용하기 때문에 빠른 삽입, 삭제, 검색을 제공한다.

단, 이때 해시 함수로 인해 중복된 index가 발생할 수 있는데 이것을 해시 충돌이라 한다.  


## 2. 해시 충돌 회피 방법

---
해시 충돌을 회피하는데 크게 2가지 방법이 있다.  

첫 번째는 `separate chaining`이다.  
충돌이 발생하면 기존 값과 새로운 값을 연결리스트로 연결하는 방법이다.  
이는 충돌을 대비해 공간을 미리 준비할 필요가 없는 장점이 있지만,  
같은 hash에 많은 값이 연결되면 검색 성능이 떨어진다는 단점이 있다.  


두 번째는 `open addressing`이다.
충돌이 발생하면 빈 공간을 찾아 저장하는 방법이다.  
현재의 index로 부터 고정폭 만큼씩 이동하며 빈 공간을 찾는 Linear Probing 방법 외에도  
Quadratic Probing, Double Hashing Probing 같은 것이 있다.  

Java의 `HashMap`은 separate chaining을 사용한다.  
그 이유는 크게 두 가지가 있다.  
1. HashMap에서 remove()는 빈번하게 호출될 수 있는 메서드인데, open addressing은 데이터 삭제 연산을 효율적으로 처리하기 어렵다.   
2. open addressing의 경우 해시 버킷을 채운 밀도가 높아질수록 worst case 발생율이 높아지지만 separate chaining은 보조 해시 함수를 이용해 worst case 발생율을 줄일 수 있다.  


## 3. Java 7에서의 HashMap

---
Java 7에서 HashMap의 put() 메서드를 살펴보며 중요한 점을 짚어보겠다.
```java
public V put(K key, V value) {
    if (table == EMPTY_TABLE) {  
        inflateTable(threshold);    // table 배열 생성
    }
    if (key == null)   // null을 키로 사용한 경우
        return putForNullKey(value);

    // hashCode()를 사용하는 것이 아니라 보조 해시 함수를 이용하는 변형된 해시 함수를 사용한다.    
    int hash = hash(key);    

    // i 값이 해시 버킷의 인덱스이다.
    // indexFor()는 hash % table.length와 같은 의도의 메서드이다.
    int i = indexFor(hash, table.length);

    // 해시 버킷에 있는 Linked List를 순회한다.
    // 만약 같은 키가 이미 저장되어 있다면 교체한다.
    for (Entry<K,V> e = table[i]; e != null; e = e.next) {
    Object k;
        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

     modCount++;

    // 버킷의 마지막 Entry 참조값, key, value, hash를 저장하는 새로운 Entry를 생성해 저장한다. 
    addEntry(hash, key, value, i);
    return null;
}

static class Entry<K,V> implements Map.Entry<K,V> {
    final K key;
    V value;
    Entry<K,V> next;
    int hash;

    // ... 
}
```
- hashCode() 사용이 아닌 hash()라는 보조 해시 함수(변형된 해시 함수)를 사용한다
- 해시 버킷 index를 (hash % table.length)와 같이 계산한다
- Entry 클래스를 통해 LinkedList 구조를 갖추고 있다

이를 통해 아래와 같은 코드를 실행시킨다면 어떤 결과를 출력할지 알 수 있다.
```java
public static void main(String[] args) {

    HashMap<Book, String> map = new HashMap<>();
    Book book1 = new Book(1, "오브젝트");
    Book book2 = new Book(1, "객체 지향의 사실과 오해");
    Book book3 = new Book(2, "토비의 스프링 Vol.1");

    map.put(book1, "First Input");
    map.put(book2, "Second Input");
    map.put(book3, "Third Input");

    System.out.println(map.get(book1));  
    System.out.println(map.get(book2));   
}

static class Book {

    private int category;
    private String title;

    public Book(int category, String title) {
        this.category = category;
        this.title = title;
    }

    @Override
    public int hashCode() {
        return category;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Book key = (Book) o;
        return category == key.category && Objects.equals(title, key.title);
    }
}
```
`Book` 클래스의 hashCode()가 category 값을 리턴하기에 book1과 book2는 동일한 해시값을 갖게 된다.  
따라서 해시 충돌이 발생을 하지만 동일한 해시 버킷에 LinkedList 형태로 저장되며  
아래와 같이 두 개의 value 모두 출력됨을 볼 수 있다.  
```text
First Input
Second Input
```


## 3. Java 8에서의 HashMap

---
Java 7과 달리 Java 8에서는 하나의 해시 버킷에 8개의 key-value 쌍이 모이면 LinkedList를 Tree로 변경한다.  
만약 개수가 6개로 줄어든다면 다시 LinkedList로 변경한다.  
```java
static final int TREEIFY_THRESHOLD = 8;
static final int UNTREEIFY_THRESHOLD = 6;
```

그리고 Entry 대신 Node 클래스를 사용한다.  
Tree 구조로 값을 저장할 수 있게 하위 클래스인 TreeNode도 존재한다.  
```java
static class Node<K, V> implements Map.Entry<K, V> {
    final int hash;
    final K key;
    V value;
    Node<K, V> next;
    
    Node(int hash, K key, V value, Node<K, V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }
    		
    // ...
}
    
static final class TreeNode<K, V> extends LinkedHashMap.Entry<K, V> {
    TreeNode<K, V> parent;
    TreeNode<K, V> left;
    TreeNode<K, V> right;
    TreeNode<K, V> prev;
    boolean red;
    
    TreeNode(int hash, K key, V val, Node<K, V> next) {
        super(hash, key, val, next);
    }
    
    // ...
} 
```