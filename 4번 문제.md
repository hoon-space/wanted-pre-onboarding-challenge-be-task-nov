
(4) 본인이 주력으로 사용하는 언어에서 설계적 결함 한 가지를 작성해주세요.

java가 해결하고자 만들었던 부분이 오히려 설계적 결함으로 나타날 수 있다. 어떤 설계적 결함이 있는지 공부해보고자 한다.

## Java의 설계적 결함들

> 설계적 결함(Design Flaw)이란 시스템 또는 소프트웨어의 설계 과정에서 발생한 심각한 오류나 미스 디자인을 의미한다.
> 

이러한 결함들이 문제가 되는 이유는 프로그램의 동작에 문제를 일으키거나 유지보수를 어렵게 만들 수 있기 때문이다.

## 설계적 결함이 등장하는 상황들

1. **언어의 불일치된 문법**: 언어의 문법이 다소 혼란스럽거나 일관성이 없을 때 발생한다.
2. **타입 시스템의 한계**: 언어의 타입 시스템이 제한적이거나 혹은 너무 복잡할 때 발생한다.
3. **프로그램의 성능 문제**: 언어의 실행 속도나 메모리 관리 등이 효율적이지 않을 때 발생한다.
4. **표현력의 한계**: 언어가 특정 유형의 문제를 해결하기 어려울 때 발생한다.
5. **라이브러리 및 생태계의 한계**: 언어의 생태계가 충분히 발전하지 않아 필요한 라이브러리나 도구를 사용하기 어려울 때 발생한다.

이렇게 다양한 상황에서 설계적 결함이 발생하는데, Java는 이 중 어떤 결함을 가지고 있을까.

## 대표적 설계적 결함

> Java는 Null 지원이나 다중 상속 미지원, 런타임 성능 등의 결함이 있다.
> 

그런데 이 결함들 중, 개인적으로는 코드를 짜면서 **원시 타입(primitive types)과 래퍼 클래스(wrapper classes)**의 혼용이 **매우 엄격한 점**이 결함으로 느껴졌다.

### ✍️ **원시 타입(primitive types)과 래퍼 클래스**

Java에는 `int, double`과 같은 원시 타입과 `Integer, Double`과 같은 래퍼 클래스가 존재한다. 이 두 가지를 혼용하여 사용할 경우 자동 언박싱 및 오토박싱으로 인한 1) **성능 저하가 발생**할 수 있다.

* 자동 언박싱(autounboxing)과 오토박싱(autoboxing)은 Java에서 원시 타입(primitive type)과 래퍼 클래스(wrapper class) 간의 변환을 자동으로 처리해주는 기능이다.

---

1. **오토박싱(autoboxing):**
    - 오토박싱은 원시 타입을 래퍼 클래스로 자동으로 변환해주는 기능이다. 예를 들어, **`int`** 타입을 **`Integer`**로 변환한다.

```java
Integer num = 10; // 오토박싱: int 10이 Integer로 자동으로 변환됨
```

1. **자동 언박싱(autounboxing):**
    - 자동 언박싱은 래퍼 클래스를 원시 타입으로 자동으로 변환해주는 기능이다. 예를 들어, **`Integer`**를 **`int`**로 변환한다.

```java
int num = new Integer(10); // 자동 언박싱: Integer가 int로 자동으로 변환됨
```

이러한 기능들은 `**Java 5**`부터 도입되어 코드 작성을 편리하게 해주었지만, 사용 시에는 데이터 타입에 주의하여야 한다. 불필요하게 자동 언박싱(autounboxing)과 오토박싱(autoboxing)이 발생하면 성능 저하가 발생할 수 있다.

**예를 들어**, 원시 타입과 래퍼 클래스를 혼용하여 리스트를 다루는 경우, 리스트에 추가하거나 꺼낼 때마다 자동 언박싱과 오토박싱이 발생하여 성능이 저하될 수 있다.

2) **비교 연산자의 동작 차이가 문제가 될 수도 있다.** 래퍼 클래스는 객체이므로 **`==`** 연산자로 두 객체를 비교할 경우 참조 비교가 된다. 반면에 원시 타입은 값 자체를 비교한다. 사용에 주의해야한다.

```java
Integer a = 10;
Integer b = 10;
System.out.println(a == b); // false (참조 비교)

int x = 10;
int y = 10;
System.out.println(x == y); // true (값 비교)
```

3) **메서드 호출 시 시그니처 충돌**: 메서드의 시그니처가 래퍼 클래스와 원시 타입의 경우에 따라 다를 수 있다. 이로 인해 코드 가독성이 떨어진다.

1. **메서드 오버로딩(Overloading)**: 같은 이름의 메서드가 매개변수의 타입, 개수, 또는 순서 등이 다르게 정의되어 있는 경우다. 이때 어떤 메서드가 호출될지 판단하기 위해선 호출 시 제공되는 인자의 정보를 통해 해당 메서드를 찾아야 한다. 이 과정에서 매개변수의 타입이나 개수 등을 정확히 알아야 하기 때문에 가독성이 떨어질 수 있다.
2. **다중 상속(Interface Implementation)**: 클래스가 여러 개의 인터페이스를 구현하는 경우, 이 인터페이스들이 동일한 이름의 메서드를 가질 수 있다. 이 경우 어떤 인터페이스의 메서드가 호출되는지 알아내기 위해서는 호출하는 측에서 해당 메서드의 정확한 시그니처를 알고 있어야 한다.

이런 경우에는 코**드를 읽는 사람이나 유지보수하는 개발자가 정확한 시그니처를 알고 있어야 하므로** 가독성이 떨어질 수 있다. 따라서 메서드의 이름, 매개변수, 반환 타입 등을 명확하게 지어주고, 호출하는 측에서는 정확한 시그니처를 사용하여 메서드를 호출하는 것이 좋다.

```java
public void process(int value) { ... }
public void process(Integer value) { ... }
```

4) **컬렉션에서의 사용**: 컬렉션은 원시 타입을 저장할 수 없으므로 래퍼 클래스를 사용해야 한다. 혼용하게 되면 자주 변환 작업이 필요할 수 있다.

```java
List<Integer> integerList = new ArrayList<>();
List<int> intList = new ArrayList<>(); // 에러 발생
```

5) **Null 값 다루기**: 래퍼 클래스는 **`null`**을 허용할 수 있지만 원시 타입은 그렇지 않다. 따라서 혼용하면 **`NullPointerException`**이 발생할 수 있다.

따라서, 원시 타입과 래퍼 클래스를 혼용하는 것은 가능하나 주의가 필요하다. 일반적으로는 가능한한 한 가지 타입을 사용하여 혼란을 줄이고 성능을 향상시키는 것이 좋다.

### 다른 언어들의 사례

다른 언어들은 원시 타입과 래퍼 클래스를 각각의 방식으로 다루기도 하지만, 몇몇 언어들은 원시 타입과 래퍼 클래스의 구분을 덜 엄격하게 다룬다. 예를 들어, Python과 JavaScript는 변수의 타입을 명시적으로 선언하지 않기 때문에 개발자가 신경 쓰지 않아도 된다. C++과 같은 언어도 상대적으로 자유로운 편이다.

하지만, Java는 원시 타입과 래퍼 클래스의 혼용으로 인한 문제를 예방하기 위해 명확한 타입 시스템을 가지고 있다. 이러한 접근 방식은 프로그램 안정성을 높이고 오류를 방지하는 데 도움이 되지만, 이로 인해 약간의 불편함이 있게 되는 것이다.

---

### 결론

그러나 자바의 이러한 결함들이 반드시 나쁜 것은 아니다. 언어의 설계 결정은 어떤 문제를 더 잘 다루기 위한 선택이며, 이러한 선택은 다른 언어에서도 이뤄진다.

또한 자바는 객체지향 프로그래밍 언어로서 강력한 런타임 환경을 제공하며, 많은 큰 프로젝트에서 사용되고 있다. 결국 언어의 적절한 사용 방법과 개발자의 스킬이 중요하다. 그리고 다른 언어들 역시 자신만의 장단점을 가지고 있기 때문에, 상황과 요구사항에 맞게 언어를 선택하는 것이 중요하다고 할 수 있겠다.