# JAVA의 설계적 결함과 대안

## 0. 시작

---
현재 java라는 언어를 사용하고 있다.  
4번 주제를 처음 보았을 때 떠오르는 것이 없었다.  
특히 '설계적 결함'에 대해 생각해본 적이 없었던 것 같고 문제의 본질이 무엇인지 파악하기 어려웠다.

## 1. 장단점

---
내가 생각하는 java의 장점은 안전한 언어라는 것이다.  
버퍼 오버런, 배열 오버런 같은 메모리 충돌에서 안전하고 자바로 작성한 클래스는 시스템의 다른 부분에서 무슨 짓을 하든 그 불변식이 지켜진다.

그러나 주의할 점이 있다.  
다른 클래스로부터의 침범을 노력 없이 모두 막을 수 있는 건 아니다.  
클라이언트가 불변식을 깨뜨리려 혈안이 되어 있다면 나는 이를 막기 위해 방어적으로 프로그래밍해야 한다.

## 2. 문제

---
```java
public final class Period {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {
        if (start.compareTo(end) > 0)
            throw new IllegalArgumentException(
                    start + "가 " + end + "보다 늦다.");
        this.start = start;
        this.end = end;
    }

    public Date start() {
        return start;
    }

    public Date end() {
        return end;
    }

}
```
위 클래스는 불변처럼 보이고, 시작 시각이 종료 시각보다 늦을 수 없다는 조건을 무리 없이 지킬 것 같다.
하지만 Date가 가변이란 점을 이용하면 어렵지 않게 불변식을 깰 수 있다.
```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78); // p 내부가 수정된다
```
Period의 내부 불변식은 쉽게 깨지게 된다.


## 3. 해결

---
### 3.1 불변 객체 사용
사실 Date는 낡은 API로 더 이상 사용되지 않는 코드이다.  
따라서 불변 객체인 Instant, LocalDateTime, ZonedDateTime을 사용하면 된다.  

하지만 Date 같은 낡은 값 타입의 사용 시절이 워낙 길었기에 여전히 많은 API와 구현에 잔재들이 남아있을 수 있다.  
이를 대처하는 방법은 없을까?

### 3.2 방어적 복사
```java
public Period(Date start, Date end) {
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());
    
    if (this.start.compareTo(this.end) > ) 
        throw new IllegalArgumentException(this.start + " after " + this.end);
}
```
Period 인스턴스 안에서 원본이 아닌 복사본을 사용하는 것이다.  
매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성을 검사하면 된다.  


## 4. 또 다른 문제?

---
```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
p.end().setYear(78);
```
Period 인스턴스를 향해 위와 같은 공격을 할 수도 있다.  
이는 접근자에 대한 수정시 방어적 복사본을 이용해 해결하면 된다.
```java
public Date start() {
    return new Date(start.getTime());
}

public Date end() {
    return new Date(end.getTime());
}
```
접근자는 가변 필드의 방어적 본사본을 반환하면 된다.


## 5. 정리

---
1. 클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.
2. 물론 복사 비용이 너무 크거나 클라이언트가 해당 요소를 수정할 일이 없음을 확신한다면 수행하지 않아도 된다.
3. 단, 해당 구성요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시해야 한다.