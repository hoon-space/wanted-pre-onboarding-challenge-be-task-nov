
# 동시에 같은 DB Table row를 업데이트 한다면 무슨 문제가 생길까?

RDBMS의 테이블에 동시에 여러 세션이 같은 테이블의 row 를 수정한다면 데이터가 예상과 다르게 변경될 수 있다. 따라서 동시성 제어에 대한 해결책이 필요하다.



# Optimistic Lock VS Pessimistic Lock

## Opimistic Lock (낙관적 락)

> 리소스에 Lock을 걸어서 선점하지 않고, **동시성 문제가 발생하면 그때 가서 처리**하는 방법론



- 트랜잭션의 충돌이 발생하지 않을 것이라고 기대한다.

- 충돌이 아는 것을 미리 막지 않고, 충돌이 난 것을 감지하면 그때 처리한다.

- 일반적으로 version 또는 timestamp를 비교하여 충돌을 확인하고, rollback을 진행한다.

- 여러 작업이 묶인 트랜잭션으로 요청이 실패한 경우 개발자 직접 rollback 처리를 해야한다.

- 어플리케이션 단에서 동시성을 처리한다.



  ```
  -- 1번 user 닉네임 : kgs, 초기 version : 1
  -- 가장 먼저 업데이트 된 것을 적용한다고 가정
  
  Request A : 1번 User의 닉네임을 gs kim 으로 변경
  Request B : 1번 User의 닉네임을 kim gs으로 변경
  
  A : version 1의 1번 user의 닉네임을 gs kim 으로 변경 하고 version 2로 업데이트 요청
  B : version 1의 1번 user의 닉네임을 kim gs로 변경하고 version 2로 업데이트 요청
  
  -- 2번 요청이 먼저 완료되는 경우
  user의 닉네임이 kim gs으로 변경되고 version 2로 변경
  A 요청의 경우 version 1이 사라졌기 때문에 충돌 발생, 업데이트 실패
  (충돌 발생 시 처리방법은 개발자가 결정)
  
  ```

### 장점

- 충돌이 자주 발생하지 않는 가정 하, 동시 요청에 대한 처리 성능이 좋다.

### 단점

- 충돌이 자주 발생하는 경우 롤백 처리에 대한 비용이 많이 들어 오히려 성능에서 손해를 볼 수 있다.
- 롤백 처리를 구현하는게 복잡할 수 있다.



## Pessimistic Lock (비관적 락)

> 리소스 요청에 따른 동시성 문제가 발생할 것이라고 예상하고 Lock을 걸어버리는 방법론



- 트랜잭션의 충돌이 발생한다고 가정한다.

- 하나의 트랜잭션이 리소스에 접근 시 Lock을 걸어 다른 트랜잭션이 접근하지 못하도록 한다.

- 데이터베이스에서 Shared Lock 또는 Exclusive Lock을 건다.

    - Shared Lock의 경우, 다른 트랜잭션에서 읽기만 가능하다. 또한 Exclusive Lock 적용이 불가능하다.

    - Exclusive Lock의 경우, 다른 트랜잭션에서 읽기 및 쓰기가 모두 불가능하다. 또한, 추가적인 Shared, Exclusive Lock 적용이 불가능하다.



  ```
  -- 1번 user 닉네임 : kgs
  -- Exclusive Lock이라고 가정
  
  Request A : 1번 User의 닉네임을 gs kim 으로 변경
  Request B : 1번 User의 닉네임을 kim gs으로 변경
  
  1. A 시작 1번 user의 닉네임을 수정하기 위해 Exclusive Lock을 획득
  2. B 시작 1번 user의 닉네임을 수정하려고 시도하지만 A가 이미 Exclusive Lock을 설정했기 때문에 대기상태로 전환
  3. A 수행 - 1번 user의 닉네임을 gs kim으로 수정하고 업데이트
  4. B 대기 - A의 Exclusive Lock이 해제될 때까지 대기
  5. A의 업데이트를 마치고 Lock 해제
  6. B 재시작 - B가 Lock 획득 후 해당 데이터를 수정하려고 시도
  7. B 수행 - 1번 user의 닉네임을 kim gs로 수정하고 업데이트
  8. B의 업데이트를마치고 Lock 해제
  
  ```



### 장점

- 충돌이 자주 발생하는 환경에서 롤백의 횟수를 줄일 수 있어서 성능에서 유리하다.
- 데이터 무결성을 보장하는 수준이 매우 높다,.

### 단점

- 데이터 자체에 Lock을 걸어서 동시성이 떨어져 성능 손해를 볼 수도 있다. 특히 read가 많이 이루어지는 경우 손해가 더 발생할 수 있다.
- 서로 자원이 필요한 경우 Lock으로 인해 DeadLock이 발생할 수 있다.
    - 트랜잭션들이 Lock을 획득하는 순서를 일관되게 정의해서 데드락의 가능성을 줄일 수 있다.



## 결론

- 낙관적 락은 데이터 충돌이 자주 일어나지 않을 것이라고 예상되는 경우 사용한다.
- 비관적 락은 데이터의 무결성이 중요하고, 충돌이 자주 발생될 것이라고 예상되는 경우 사용한다.
- 나의 의견으로는 데이터의 무결성이 가장 중요하므로 비관적 락을 우선적으로 사용하고 서비스를 운영하면서 충돌이 자주 발생하지 않고 성능적으로 개선이 필요하다고 판단되면 낙관적 락으로 변경할 것 같다.



# Lock

데이터베이스는 여러 사용자들이 같은 데이터를 동시에 접근하는 상황에서, 데이터의 무결성과 일관성을 지키기 위해 Lock을 사용한다. Lock이란 트랜잭션 처리의 순차성을 보장하기 위한 방법이다.



### Lock의 설정 범위 (Level)

- 데이터베이스

  전체 데이터베이스를 기준으로 Lock 하는 것이다. 1개의 세션만이 DB의 데이터에 접근이 가능하다.

- 파일

  데이터베이스 파일을 기준으로 Lock을 설정한다. 여기서 파일이란 테이블, row 등과 같은 실제 데이터가 쓰여지는 물리적인 저장소이다.

- 테이블

  테이블을 기준으로 Lock을 설정한다. 이는 테이블의 모든 행을 업데이트 하는 등의 테이블에 영향을 주는 변경을 수행할 때 유행하다. 즉 CREATE, ALTER 등과 같은 DDL 구문과 함께 사용되어 DDL Lock이라고도 한다.

- 페이지와 블록

  파일의 일부인 페이지와 블록을 기준으로 Lock을 설정한다.

- 컬럼

  컬럼 기준의 Lock은 컬럼을 기준으로 Lock을 설정한다. 많은 리소스가 필요하여 일반적으로 사용되지 않는다.

- 행

  행 수준의 Lock은 1개의 row를 기준으로 Lock을 설정한다. DML에 대한 Lock으로 가장 일반적으로 사용하는 Lock이다.

### Lock의 종류

- Shared Lock (공유 락)

  데이터를 변경하지 않는 읽기 명령에 대해 주어지는 Lock으로 Read Lock이라고도 한다.

  여러 사용자가 동시에 데이터를 읽어도 데이터 일관성에는 아무 영향이 없기에, 공유 락끼리 동시 접근이 가능하다. 하지만 공유 락이 설정된 데이터에 배타 락을 사용할 수는 없다.



- Exclusive Lock (배타 락)

  배타 락은 데이터에 변경을 가하는 명령에 대해 주어지는 Lock으로 Write Lock이라고도 한다.

  배타 락을 얻은 트랜잭션은 다른 트랜잭션들이 동시에 읽기 락이나 쓰기 락을 얻는 것을 막는다.

  mutex(뮤텍스)와 유사하다.