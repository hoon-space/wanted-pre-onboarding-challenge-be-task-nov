
(1) 동시에 같은 DB Table row 를 업데이트 하는 상황을 방어하기

요즘은 한 어플리케이션 내에서도 여러 서버 또는 서비스가 동시에 동작하는 경우가 대부분이다. 즉 각각의 서버에서 데이터를 업데이트하는 경우가 많다. 

동시에 여러 사용자가 시스템을 사용하고 데이터를 수정하는 경우, 동일한 데이터에 대한 업데이트 요청이 동시에 발생하거나, 혹은 대용량 데이터를 처리하는 배치 작업에서 여러 프로세스가 동시에 데이터를 수정할 수도 있다. 

그 외에 네트워크 상의 지연으로, 트랜잭션 충돌 등의 이유로도 DB는 동시에 업데이트가 될 수 있는데, 이는 다양한 문제를 일으킬 수 있다.

## 동시에 DB 접근할 시 생길 수 있는 문제들

1. **당연히 업데이트가 손실될 수 있다**:
    - 먼저 업데이트를 요청한 클라이언트가 새로운 값으로 데이터를 업데이트 했음에도 그 후에 다른 클라이언트가 같은 데이터를 다른 값으로 업데이트하면, 처음에 업데이트한 내용이 손실된다.
2. **데이터가 일치하지 않는다**:
    - 동시에 업데이트를 진행하는 경우, 데이터베이스의 상태가 예상치 못한 방향으로 변할 수 있다. 이로 인해 데이터 간의 일관성이 깨지게 된다.
3. **Race Condition**:
    - 두 개 이상의 프로세스나 스레드가 동시에 같은 데이터를 업데이트하려고 할 때, 먼저 완료된 업데이트만이 반영되고 나머지는 무시될 수 있다.
4. **데이터 손상**:
    - 동시에 같은 행을 업데이트하면, 데이터베이스가 예기치 않은 오류 상태로 변할 가능성이 있다. 이로 인해 데이터의 무결성이 손상될 수 있다.
5. **성능 문제**:
    - 동시 업데이트는 락을 사용하거나 병합 작업이 필요할 수 있어 성능 저하를 초래할 수 있다.
6. **Deadlocks**:
    - 두 개 이상의 트랜잭션이 서로가 소유한 락을 대기하면서 데드락에 빠질 수 있다.
7. **애플리케이션 오류**:
    - 동시 업데이트가 발생하면 예상치 못한 결과가 발생할 수 있어 애플리케이션의 동작에 문제를 일으킬 수 있다.
    

### 그렇다면, 해당 문제를 해결하기 위해서 어떻게 하면 좋을까?

---

## ✔️ DB 동시 업데이트를 해결하는 방법들

### 1️⃣ **Optimistic Lock**

> 데이터를 읽을 때 **버전 번호**를 함께 읽어오고, 업데이트할 때 이 버전 번호를 비교하여 업데이트를 허용하거나 거부하는 방법이다.
> 

DB 차원에서 레코드를 잠그는 방법이다.

만약 두 개의 클라이언트가 동시에 같은 행을 읽어와서 업데이트하려고 한다면, 먼저 업데이트를 시도한 클라이언트만이 성공하고 나머지는 실패한다.

Spring에서는 JPA와 Hibernate를 사용하여 버전 관리를 쉽게 구현할 수 있다.

- 구현 방법
    - 테이블에 버전 번호 컬럼을 추가한다.
    - 행을 읽을 때마다 **해당 버전 번호**도 함께 가져온다.
    - 업데이트를 시도할 때 이전에 읽은 버전 번호와 현재 행의 버전 번호를 비교하여 업데이트를 수행하거나 거부한다.

그러나 이에는 몇가지 문제가 있다. 

1. 업데이트 시도한 클라이언트가 실패할 경우 롤백을 해야하는데, 이는 추가적 오버헤드를 발생시킨다.
2. 이 방법은 락을 사용하지 않기에 트랜잭션 충돌이 발생하지는 않지만 동시에 업데이트가 많은 환경에서는 데이터베이스 부하가 증가할 수 있다.
3. 읽어올 때 버전 정보를 함께 읽어와야 하므로 읽기 작업에 대한 오버헤드가 있을 수 있다. 
4. 동시 업데이트가 발생했을 때, 어떻게 충돌을 해결할지에 대한 전략이 필요하다. 일례로 충돌이 감지되면 클라이언트에게 알려주고 클라이언트가 적절한 조치를 취하는 등의 방법이 있다.

### 2️⃣ **Pessimistic Lock**

> 행을 읽을 때 바로 락을 걸어 다른 클라이언트가 해당 행을 읽거나 업데이트 할 수 없도록 한다. 수정이 끝난 후에 잠금을 해제한다.
> 

데이터를 읽을 때 락을 걸기 때문에, 다른 클라이언트가 해당 데이터를 수정하는 것을 애초에 방지할 수 있다. Optimistic Lock에 비해 안전하다. 그런데 락이 오래 지속되면 다른 클라이언트의 대기 시간이 늘어날 수 있고, 이는 성능에 영향을 미칠 수 있다. 또한, 락을 사용하면 동시성이 감소한다는 점을 유념해야한다.

- 구현 방법
    - 읽을 때 SELECT ... FOR UPDATE 문을 사용하여 해당 행에 락을 걸어 다른 클라이언트가 해당 행을 읽거나 업데이트할 수 없도록 한다.

### 3️⃣ Transaction 사용

트랜잭션을 사용하여 여러 쿼리를 하나의 원자적인 작업으로 묶는다. 동시에 같은 행을 업데이트 할 경우 트랜잭션 내에서 처리되므로 동시 업데이트 문제가 발생하지 않는다. 

애플리케이션에서는, 트랜잭션 격리 수준을 설정하여 동시에 여러 트랜잭션이 실행될 때 어떻게 처리할지 정의한다.

- 구현 방법
    - BEGIN TRANSACTION으로 트랜잭션을 시작하고, 업데이트 쿼리를 실행한 후 COMMIT으로 트랜잭션을 종료한다.

### 4️⃣ 큐 사용

> 업데이트 작업을 순차적으로 처리하기 위해 큐를 사용할 수 있다. 동시에 업데이트 요청이 들어오면 큐에 추가하고, 순차적으로 처리하는 매커니즘을 만들게 된다.
> 
- *큐 시스템을 선택하고, 업데이트 요청을 큐에 추가한 후 워커 프로세스를 이용하여 순차적으로 처리한다.

---

* 여기서 큐 시스템이란, RabbitMQ, Apache Kafka, Redis와 같은 동시성 문제 해결 용 소프트웨어를 말한다. 

이 동시 업데이트를 방어하기 위해 업데이트 요청을 큐에 추가한다. 업데이트를 시도하는 클라이언트는 먼저 큐에 업데이트 요청을 넣는다. 

업데이트를 처리할 워커 프로세스를 구현한다. 하나의 업데이트 작업이 끝나면 다음 작업을 처리한다. 이 큐 시스템은, 동시에 같은 데이터를 업데이트 하려하는 경우에 어짜피 큐에서 업데이트 요청을 차례대로 처리하므로 충돌이 발생하지 않는다. 따라서 충돌 해결 매커니즘이 필요하지 않다.

이는 분산 시스템에서도 잘 동작하며 병렬 처리가 가능하고 워커 프로세스를 통해 순차적으로 업데이트를 처리할 수 있어 데이터의 무결성을 보장한다. 단점이란 큐 시스템의 구성과 관리가 필요하다는 점이 있겠다. 

## 언제 이 방법들을 사용하는가

이렇게 많이 살펴보았는데 다 장단점이 있기에, 언제 이 방법을 사용할지에 대해서 고민해봐야한다.

**일반적으로 대규모 분산 시스템**에서는 데이터베이스 레벨에서의 **Optimistic Lock**이나 **Pessimistic Lock**, 그리고 트랜잭션을 활용하여 동시 업데이트 문제를 해결하는 경우가 많다.

큐 시스템은 비동기적으로 작업을 처리하고 분산 시스템에서의 작업 조율을 위해 사용된다.

최근에는 클라우드 네이티브 환경에서의 서비스 메시지 큐나 스트리밍 플랫폼 (예: Apache Kafka)의 활용이 증가하고 있다. 이는 대규모 데이터 처리 및 이벤트 스트리밍에서 동시성 문제를 해결하는 데 사용된다.